<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xiangmiao Yue</title>
  
  <subtitle>确保每天都在进步</subtitle>
  <link href="https://pangpangfei.github.io/atom.xml" rel="self"/>
  
  <link href="https://pangpangfei.github.io/"/>
  <updated>2021-07-21T13:08:34.554Z</updated>
  <id>https://pangpangfei.github.io/</id>
  
  <author>
    <name>Yue/53795936@qq.com</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>百度前端训练营2021大作业</title>
    <link href="https://pangpangfei.github.io/2021/07/21/%E7%99%BE%E5%BA%A6%E5%89%8D%E7%AB%AF%E8%AE%AD%E7%BB%83%E8%90%A52021%E5%A4%A7%E4%BD%9C%E4%B8%9A/"/>
    <id>https://pangpangfei.github.io/2021/07/21/%E7%99%BE%E5%BA%A6%E5%89%8D%E7%AB%AF%E8%AE%AD%E7%BB%83%E8%90%A52021%E5%A4%A7%E4%BD%9C%E4%B8%9A/</id>
    <published>2021-07-21T03:54:47.000Z</published>
    <updated>2021-07-21T13:08:34.554Z</updated>
    
    <content type="html"><![CDATA[<p>最近参加了百度前端训练营（据说有实习机会和校招通道，很心动），最终有两个大作业四个版本，这边篇章就是其中一个关于餐厅游戏项目的实现总结。</p><span id="more"></span><h2 id="项目相关"><a href="#项目相关" class="headerlink" title="项目相关"></a>项目相关</h2><h3 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h3><p><a href="https://gitee.com/PangPangDeXiong/web-mooc_restaurant">gitee链接</a></p><h3 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h3><p><a href="https://mp.weixin.qq.com/s/lIQ2WH6Zvvr_b4VpRFTdqg">百度前端训练营</a>的<a href="https://github.com/webmooc/webmooc-practice/blob/master/practice_chs/restaurant.md">餐厅作业（项目的需求在链接里）</a>。</p><h3 id="项目愿景和价值"><a href="#项目愿景和价值" class="headerlink" title="项目愿景和价值"></a>项目愿景和价值</h3><ul><li>项目为作业项目，并且要求不依赖框架完成任务，我已经很久没有写过纯JavaScript的项目了，所以也是尝试完成项目也是一个成长吧。</li><li>在参加训练营的过程中发现有些同学是刚学习前端的同学，还没有能力完成该作业，所以将我的实现过程分享给他们或许是最大的价值。</li></ul><h3 id="项目的阶段和排期"><a href="#项目的阶段和排期" class="headerlink" title="项目的阶段和排期"></a>项目的阶段和排期</h3><p>刚开始看见这个大作业的时候，打算先完整的作出设计，拆分任务然后才开始写代码。但是等我有时间写项目的时候预计可以写代码的时间已经不够4天，所以在做工期预测的时候知识将项目拆解功能拆解成了几个大类，疑难点提炼出来，将这些做了一个时间的整体预估，所以具体的排期这里就不展示了。<br>项目的阶段，我觉得理应分为四个阶段吧：</p><ol><li>完成页面样式的样式（HTML，CSS部分）</li><li>完成拆解的各个组件</li><li>组装各个组件（完成组件之间的逻辑交互）</li><li>自测</li></ol><p>而实际因为没有细分任务的原因将第二第三阶段柔和在一起了，提交作业马上截止的时候才完成代码，所以也没有自测（所以代码中可能有一些流程上的bug）。</p><h3 id="分析要求"><a href="#分析要求" class="headerlink" title="分析要求"></a>分析要求</h3><h4 id="要求项"><a href="#要求项" class="headerlink" title="要求项"></a>要求项</h4><ol><li>兼容性满足PC Chrome下的移动调试窗口 + 手机自带浏览器，不需要兼容微信，UC等第三方浏览场景；</li><li>代码风格优雅，代码结构合理，技术设计恰到好处；</li><li>框架使用方面，建议不使用框架实现一遍，然后再使用框架实现一遍；</li><li>只能附件中提供的图片资源，其他样式均使用 CSS 实现；如果有额外自己添加的需求场景，可以自行按需求增加图片资源；</li><li>提供的原始图片资源体积较大，根据实际需要进行性能优化所需要的压缩。</li></ol><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><ol><li>在PC Chrome下开发，并且体现移动端调试的能力；</li><li>代码有实现在一定的规则下完成，有一定的可读性，不要过渡的设计框架代码，比如自己实现个虚拟DOM，那可能有点过渡设计；</li><li>视频中老师说没有必要用框架实现一遍，所以只需要用最原始的方法（HTML, CSS, JavaScript）实现一遍即可；</li><li>项目中需要的类似图标却没有给的图片资源有三个（添加厨师的白色头像，添加厨师的加号，解聘厨师的叉）；</li><li>将图片压缩一下（这个我没做，因为我觉得图片的优化不止压缩这么简单，关键是没时间了）。</li></ol><h3 id="分析项目中遇到的疑惑"><a href="#分析项目中遇到的疑惑" class="headerlink" title="分析项目中遇到的疑惑"></a>分析项目中遇到的疑惑</h3><p>在分析需求的过程中有发现了很多疑惑，比如：</p><ul><li>周数在野蛮生长的情况下数字位数超过能显示的宽度怎么办；</li><li>要不要保证餐厅的最大收益，就是在安排厨师做菜的时候要不要设计个算法，保证餐厅的最大收入（感觉像是动态规划），还是上先点的菜（我的实现是后者）;</li><li>当金钱不够的时候不能解聘厨师，那每周计算厨师工资的时候钱不够的话是不是就游戏结束了；</li><li>菜单的钱能不能有小数；</li><li>等等。</li></ul><p>在正常的工作环境中，遇到这些疑惑，可能要拉着产品一起去会议室打架，而此次作业我的处理方式是综合自己对于产品的理解和工期去处理问题，并没有和老师有进一步的交流，下面的内容可能对于一些疑惑有描述。</p><h3 id="对于本次实现代码过程中的不满"><a href="#对于本次实现代码过程中的不满" class="headerlink" title="对于本次实现代码过程中的不满"></a>对于本次实现代码过程中的不满</h3><blockquote><p>每次写完项目都会有一些不满来成为下次项目的开始，当然这个项目也不例外。<br>-Xiangmiao Yue</p></blockquote><ol><li>很多公用UI组件没有抽象出来（只抽象了Modal, Toast），导致很多样板代码，比如进度条的组件；</li><li>为了保证JavaScript和CSS的解偶合，保证了绝大多数的样式操作都是操作节点的类名，导致类名散落在JavaScript代码的各个角落，考虑是不是能把类名写在JavaScript代码的某一个地方，做成一个字典；</li><li>很多JavaScript代码没有封装成工具函数，比如类名的添加要写很长的代码（$dom.classList.add）,这样的代码在DOM的各个地方都有用到；</li><li>没有做按钮没有做避免快速重复的点击；</li><li>没有限制业务数据的数据流，比如我们都知道React的数据流是自顶向下的，只能在顶层去操作数据，这是个很好的设计，但是在这个项目中却没有体现，导致我在发现一个bug的时候，去排查bug都很蒙圈；</li><li>很多文字相关的内容并没有单独的拿出来，而是偶合到了JavaScript中。</li></ol><h2 id="前端相关"><a href="#前端相关" class="headerlink" title="前端相关"></a>前端相关</h2><h3 id="架构相关"><a href="#架构相关" class="headerlink" title="架构相关"></a>架构相关</h3><h4 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h4><p><img src="/images/jiagoutu1.png" alt="架构图"><br>说明：其中逻辑层表示JavaScript代码的模块，表现层表示CSS代码模块。</p><h4 id="逻辑层各模块职能"><a href="#逻辑层各模块职能" class="headerlink" title="逻辑层各模块职能"></a>逻辑层各模块职能</h4><ul><li>UI组件：将页面中通用的UI抽象出来，比如弹窗，这里其实抽象出至少10个组件的，但是由于开发工期比较短，所以就抽象了两个：<ul><li>Modal(/js/index.js): 对话框；</li><li>Toast(/js/index.js): 提示框。</li></ul></li><li>CONFIG(/js/index.js)：项目的配置文件，用来配置一些，比如初始化金钱数量之类的可配置项；</li><li>Utils(/js/index.js)：通用的函数；</li><li>逻辑组件(/js/index.js)：业务相关的抽象类；<ul><li>Cook(/js/index.js)：厨师；</li><li>Customer(/js/index.js)：顾客；</li><li>BOSS(/js/index.js)：你；</li><li>App(/js/index.js)：餐厅。 </li></ul></li></ul><h3 id="技术相关"><a href="#技术相关" class="headerlink" title="技术相关"></a>技术相关</h3><h4 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h4><h5 id="flex-rem布局"><a href="#flex-rem布局" class="headerlink" title="flex+rem布局"></a>flex+rem布局</h5><p>flex+rem是移动端比较常用的布局方案了,写起来比较方便，对于手机端兼容也比较好。<br>其中为了使用rem布局，引入了flexible.js处理不同手机下跟元素字体大小的问题，而rem单位的计算借助于vscode的cssrem插件。具体的细节可以在网上搜搜相关的文章，有很多。</p><h5 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h5><p>写个游戏你如果不抽象几个类，那就挺抽象的。<br>这里提一点就是，这个项目采用了组合类的办法来维护类之间的通信。<br>类似下面代码这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span>() </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.boss = <span class="keyword">new</span> BOSS(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BOSS</span>() </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">app</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.app = app;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">doSomething</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> Cook(<span class="built_in">this</span>.app);</span><br><span class="line">    <span class="keyword">new</span> Customer(<span class="built_in">this</span>.app);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cook</span>() </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">app</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.app = app;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span>() </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">app</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.app = app;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就保证所有的类里面都能获取到BOSS和App的实例，来实现类之间的通信。</p><h5 id="定时器选择"><a href="#定时器选择" class="headerlink" title="定时器选择"></a>定时器选择</h5><p>先说明这里是通过<strong>requestAnimationFrame</strong>实现的定时装置。<br>可能提到定时器的选择，很多人会选择<strong>setTimeout</strong>或<strong>setInterval</strong>,但是我们知道，这两个api并不是在你预期的时间执行代码（如果主线程任务被占用的情况下），所以很难去设定这个间隔的值，所以我们这里使用<strong>requestAnimationFrame</strong>不断的轮询来实现定时器，虽然<strong>requestAnimationFrame</strong>多用于动画。</p><h4 id="逻辑实现"><a href="#逻辑实现" class="headerlink" title="逻辑实现"></a>逻辑实现</h4><p>具体的逻辑实现，看代码就好了。而切每个类中的方法处理我觉得也不是很优雅。<br>需要注意的是，在每个类中都实现了<strong>bindDOM</strong>和<strong>bindEvents</strong>方法，用来获取DOM节点，和绑定事件，统一处理的目的是为了解偶。<br>有些小伙伴可能已经发现了还有一些类中有<strong>bindDec</strong>方法，这个方法用来设置装饰器。其实很多地方都不应该用装饰器模式解决问题，而最好用发布订阅，比如厨师做完菜之后，会有很多人关注这个菜的的状态，我觉得理想的设计就是这些人订阅这个菜的状态，这就是这个项目中数据流设计不好的地方，也是我觉得不优雅的主要原因。</p><h4 id="进度条的优化"><a href="#进度条的优化" class="headerlink" title="进度条的优化"></a>进度条的优化</h4><p>先来看下进度条的核心代码</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> doing &#123;</span><br><span class="line">  <span class="number">0%</span> &#123;  </span><br><span class="line">      <span class="attribute">transform</span>: <span class="built_in">translateX</span>(-<span class="number">50%</span>) <span class="built_in">scaleX</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">to</span> &#123;</span><br><span class="line">      <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">0</span>) <span class="built_in">scaleX</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.running</span> &#123;    </span><br><span class="line">  <span class="attribute">animation-play-state</span>: running;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.paused</span> &#123;    </span><br><span class="line">  <span class="attribute">animation-play-state</span>: paused;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.xxxx</span> &#123;</span><br><span class="line">  will-change: transform;</span><br><span class="line">  <span class="attribute">animation-timing-function</span>: linear;</span><br><span class="line">  <span class="attribute">animation-name</span>: doing;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>曾几何时我在写进度条的时候也是直接改width，但是前两天看了一篇关于进度条的文章，很有收获，这里分享一下。<br><a href="https://mp.weixin.qq.com/s/2nk4AMvmwPWsPL1ByAs65Q">《我优化了进度条，页面性能竟提高了70%》</a></p><h2 id="规范相关"><a href="#规范相关" class="headerlink" title="规范相关"></a>规范相关</h2><h3 id="HTML相关"><a href="#HTML相关" class="headerlink" title="HTML相关"></a>HTML相关</h3><ol><li>HTML属性给CSS用的以中划(-)线分割,给JavaScript用的用下划线(_)分割；</li><li>JavaScript生成的DOM要在HTML中以注释的形式占位置，注释以DOM开头。<h3 id="CSS相关"><a href="#CSS相关" class="headerlink" title="CSS相关"></a>CSS相关</h3></li><li>书写顺序</li><li>1 位置（position,z-index,display等）-&gt; 大小（width,height,padding,margin） -&gt; 文字 -&gt; 背景边框 -&gt; 其他CSS3属性，因为可能有兼容问题所以放在最后；</li><li>2 和上下左右相关的按上 -&gt; 右 -&gt; 下 -&gt; 左的顺序。</li><li>和资源相关的放在一起定义成单独的类名，比如所有的背景图片。<h3 id="JavaScript相关"><a href="#JavaScript相关" class="headerlink" title="JavaScript相关"></a>JavaScript相关</h3></li><li>配置常量用大写加下划线命名，其他变量用驼峰命名，DOM节点变量以$开头;</li><li>所有的类属性的初始化都要在一起实现，不能随便在方法里出现未初始化的属性；</li><li>不要在类外部直接访问类属性，而是通过getter setter方法去操作。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>先说说成长吧，自打学前端以来，很少写纯原生JavaScript的项目，没有设计过这样的程序，所以在实现的过程中发现了很多可以精进的地方，在上面有提到过。还有很短的时间（4天）完成一个项目，中间还连续写了将近40个小时代码，没睡觉，这也算是一种经历上的收获吧。<br>再说说遗憾，可能就是后期为了赶工熬夜写代码，最终导致部分代码的实现比较草率，还有一些考虑的点没有写，毕竟刚开始看到这个需求的时候我满脑子都是一个问题，如果玩这个游戏的人退出了游戏，那下次他再进来的时候如何继续之前的进度。<br>还有一点遗憾可能就是这篇文章文字占比太大了，很难读，或者没有读过我的代码很难在文章上有所收获。<br>最后记录一下被我揉烂的四张需求的纸吧，还是挺值得纪念的。<br><img src="/images/xuqiu1.jpeg" alt="架构图"><br><img src="/images/xuqiu2.jpeg" alt="架构图"><br><img src="/images/xuqiu3.jpeg" alt="架构图"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近参加了百度前端训练营（据说有实习机会和校招通道，很心动），最终有两个大作业四个版本，这边篇章就是其中一个关于餐厅游戏项目的实现总结。&lt;/p&gt;</summary>
    
    
    
    
    <category term="JavaScript" scheme="https://pangpangfei.github.io/tags/JavaScript/"/>
    
    <category term="HTML" scheme="https://pangpangfei.github.io/tags/HTML/"/>
    
    <category term="CSS" scheme="https://pangpangfei.github.io/tags/CSS/"/>
    
    <category term="移动端" scheme="https://pangpangfei.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    <category term="作业" scheme="https://pangpangfei.github.io/tags/%E4%BD%9C%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript格式化时间的工具函数</title>
    <link href="https://pangpangfei.github.io/2021/06/23/JavaScript%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%B6%E9%97%B4%E7%9A%84%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0/"/>
    <id>https://pangpangfei.github.io/2021/06/23/JavaScript%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%B6%E9%97%B4%E7%9A%84%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0/</id>
    <published>2021-06-23T12:59:24.000Z</published>
    <updated>2021-06-23T14:00:59.707Z</updated>
    
    <content type="html"><![CDATA[<p>每次新建项目都得去百度偷一个处理时间的函数，不如下次从自己博客里偷。</p><span id="more"></span><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>讲一个能被Date实例化的数据转化为相应的格式<br>如：</p><table><thead><tr><th>被格式化的数据</th><th>格式化的规则</th><th>结果</th></tr></thead><tbody><tr><td>1997-09-21</td><td>yyyy.MM.dd HH:mm:ss</td><td>1997.09.21 08:00:00</td></tr><tr><td>Date.now()</td><td>yyyy-MM-dd</td><td>2021-06-23</td></tr><tr><td>Date.now()</td><td>HH:mm:ss</td><td>21:26:33</td></tr><tr><td>1624454900520</td><td>yyyy年MM月dd日HH时mm分ss秒</td><td>2021年06月23日21时28分20秒</td></tr></tbody></table><h2 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h2><ul><li>函数名<ul><li>formatDate</li></ul></li><li>参数<ul><li>date<ul><li>被格式化的数据</li><li>类型：Date</li><li>默认值：Date.now()</li></ul></li><li>fmt<ul><li>格式化的规则</li><li>类型：String</li><li>默认值：yyyy-MM-dd HH:mm:ss<h3 id="fmt不考虑的情况"><a href="#fmt不考虑的情况" class="headerlink" title="fmt不考虑的情况"></a>fmt不考虑的情况</h3>间隔内容如前一个字母相同<br>如：</li></ul></li></ul></li></ul><ul><li>yyyyyMM-dd HH:mm:ss</li><li>yyyyyMMMdddHHHmmmsss<h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2></li><li>formatDate()</li><li>formatDate(‘1997-09-21’)</li><li>formatDate(1624454900520, ‘yyyy年MM月dd日HH时mm分ss秒’)</li><li>formatDate(1624454900520, ‘yyyy.MM.dd HH(时)’)<h2 id="依赖函数"><a href="#依赖函数" class="headerlink" title="依赖函数"></a>依赖函数</h2><h3 id="格式化数字（数字位数不够自动补0）"><a href="#格式化数字（数字位数不够自动补0）" class="headerlink" title="格式化数字（数字位数不够自动补0）"></a>格式化数字（数字位数不够自动补0）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 格式化数字，当数字小于某个位数的时候，前面补0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> </span>num 需要格式化的数字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Numebr?:2&#125;</span> </span>digit 位数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;String&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatNumber</span>(<span class="params">num, digit = <span class="number">2</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> digit !== <span class="string">&#x27;number&#x27;</span> || digit &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num &lt;= <span class="built_in">Number</span>(<span class="keyword">new</span> <span class="built_in">Array</span>(digit - <span class="number">1</span>).fill(<span class="number">9</span>).join(<span class="string">&#x27;&#x27;</span>))</span><br><span class="line">        ? <span class="string">&#x27;0&#x27;</span> + num</span><br><span class="line">        : <span class="string">&#x27;&#x27;</span> + num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 格式化时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Date?:Date.now()&#125;</span> </span>date 时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String?:yyyy-MM-dd HH:mm:ss&#125;</span> </span>fmt 格式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;String&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatDate</span>(<span class="params">date = <span class="built_in">Date</span>.now(), fmt = <span class="string">&#x27;yyyy-MM-dd HH:mm:ss&#x27;</span></span>) </span>&#123;</span><br><span class="line">    date = <span class="keyword">new</span> <span class="built_in">Date</span>(date);</span><br><span class="line">    <span class="keyword">if</span> (date.toString() === <span class="string">&#x27;Invalid Date&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fmt !== <span class="string">&#x27;string&#x27;</span> || !fmt.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> o = &#123;</span><br><span class="line">        <span class="attr">yyyy</span>: date.getFullYear(),</span><br><span class="line">        <span class="attr">MM</span>: formatNumber(date.getMonth() + <span class="number">1</span>),</span><br><span class="line">        <span class="attr">dd</span>: formatNumber(date.getDate()),</span><br><span class="line">        <span class="attr">HH</span>: formatNumber(date.getHours()),</span><br><span class="line">        <span class="attr">mm</span>: formatNumber(date.getMinutes()),</span><br><span class="line">        <span class="attr">ss</span>: formatNumber(date.getSeconds())</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> s = &#123;</span><br><span class="line">        <span class="string">&#x27;*&#x27;</span>: <span class="string">&#x27;\\*&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;.&#x27;</span>: <span class="string">&#x27;\\.&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;?&#x27;</span>: <span class="string">&#x27;\\?&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;+&#x27;</span>: <span class="string">&#x27;\\+&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;$&#x27;</span>: <span class="string">&#x27;\\$&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;^&#x27;</span>: <span class="string">&#x27;\\^&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;[&#x27;</span>: <span class="string">&#x27;\\[&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;]&#x27;</span>: <span class="string">&#x27;\\]&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;(&#x27;</span>: <span class="string">&#x27;\\(&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;)&#x27;</span>: <span class="string">&#x27;\\)&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;&#123;&#x27;</span>: <span class="string">&#x27;\\&#123;&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;&#125;&#x27;</span>: <span class="string">&#x27;\\&#125;&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;|&#x27;</span>: <span class="string">&#x27;\\|&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;\\&#x27;</span>: <span class="string">&#x27;\\\\&#x27;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> regStr = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> cur;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> fmt) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur !== item) &#123;</span><br><span class="line">            cur = item;</span><br><span class="line">            <span class="keyword">if</span> (regStr.length) &#123;</span><br><span class="line">                regStr += <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            regStr += <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        regStr += s[item] || item;</span><br><span class="line">    &#125;</span><br><span class="line">    regStr += <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">    <span class="keyword">const</span> res = fmt.replace(<span class="keyword">new</span> <span class="built_in">RegExp</span>(regStr), <span class="function">(<span class="params">ign, ...arg</span>) =&gt;</span> &#123;</span><br><span class="line">        arg.length = arg.length - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> arg.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + (o[b] || b), <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2></li></ul><ol><li>将<strong>date</strong>转化为Date实例；</li><li>校验参数的合法性；</li><li>将<strong>fmt</strong>的每一项分组（如：yyyy-MM-dd -&gt; (yyyy)(-)(MM)(-)(dd)），其中正则表达式的符号需要在前面加上\，以此来作为后面需要用的正则表达式；</li><li>将<strong>fmt</strong>中的所有的日期占位符替换成真实的日期。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;每次新建项目都得去百度偷一个处理时间的函数，不如下次从自己博客里偷。&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://pangpangfei.github.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://pangpangfei.github.io/tags/JavaScript/"/>
    
    <category term="工具函数" scheme="https://pangpangfei.github.io/tags/%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript实现单例模式</title>
    <link href="https://pangpangfei.github.io/2021/06/11/JavaScript%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://pangpangfei.github.io/2021/06/11/JavaScript%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-06-11T13:29:06.000Z</published>
    <updated>2021-06-11T15:24:36.437Z</updated>
    
    <content type="html"><![CDATA[<p>我前司的后端老大哥，看见一个面试者就让人先手写个单例。</p><span id="more"></span><h2 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h2><p>简单点儿讲就是一个类仅提供一个实例，该供全局使用。</p><h2 id="单例解决的问题"><a href="#单例解决的问题" class="headerlink" title="单例解决的问题"></a>单例解决的问题</h2><p>一个全局使用的类频繁地创建与销毁。</p><h2 id="JavaScript实现单例"><a href="#JavaScript实现单例" class="headerlink" title="JavaScript实现单例"></a>JavaScript实现单例</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">getInstance</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.instance) &#123;</span><br><span class="line">            <span class="built_in">this</span>.instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Singleton.getInstance() === Singleton.getInstance()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>在上面的代码可以看出，区别于正常的类创建实例，单例模式实例的创建是在类的内部实现的，而且构造函数是不提供给外部使用的。</p><h2 id="延时构建"><a href="#延时构建" class="headerlink" title="延时构建"></a>延时构建</h2><p>研究单例到这里，你会不会有这样的想法，为什么不直接用一个<strong>对象(Object)<strong>来表示单例呢，这样用起来不是简单又大方？<br>这就引出了单例的一个重要的特征就是延时构建。<br>当我们用对象来实现一个单例的时候，在它初始化的时候就会被添加到上下文环境，而</strong>占用内存资源</strong>，而通过单例生成的对象知道使用静态类的时候才会使用资源。</p><h2 id="其他语言中的单例"><a href="#其他语言中的单例" class="headerlink" title="其他语言中的单例"></a>其他语言中的单例</h2><p>为什么要提其他语言中的单例呢，因为JavaScript区别于其他大多数语言的地方是JavaScript是<strong>单线程</strong>的。<br>多线程中资源是不共享的，所以在多线程的语言中，往往可以通过加<strong>锁</strong>实现单例。</p><h2 id="通过静态变量构建"><a href="#通过静态变量构建" class="headerlink" title="通过静态变量构建"></a>通过静态变量构建</h2><p>静态变量在线程之间是共享的，所以其他语言也可以通过静态变量实现单例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">getInstance</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Singleton.getInstance() === Singleton.getInstance()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>但是这段代码又没有实现<strong>构建延迟</strong>，所以我们通过下面的方法实现一下构建延迟，JavaScript中的class没有私有类的概念，所以下面的代码为伪代码，仅作为理解其他语言的参考。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">getInstance</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Nested.instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Nested</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>可是你在工作中经常单例吗。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我前司的后端老大哥，看见一个面试者就让人先手写个单例。&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://pangpangfei.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="JavaScript" scheme="https://pangpangfei.github.io/tags/JavaScript/"/>
    
    <category term="设计模式" scheme="https://pangpangfei.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="单例模式" scheme="https://pangpangfei.github.io/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript实现链表</title>
    <link href="https://pangpangfei.github.io/2021/05/30/JavaScript%E5%AE%9E%E7%8E%B0%E9%93%BE%E8%A1%A8/"/>
    <id>https://pangpangfei.github.io/2021/05/30/JavaScript%E5%AE%9E%E7%8E%B0%E9%93%BE%E8%A1%A8/</id>
    <published>2021-05-30T13:56:29.000Z</published>
    <updated>2021-05-30T15:56:38.211Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>链表应该是面试时被提及最频繁的数据结构。</p><ul><li>《剑指Offer》</li></ul></blockquote><span id="more"></span><h2 id="什么是链表"><a href="#什么是链表" class="headerlink" title="什么是链表"></a>什么是链表</h2><blockquote><p><strong>链表</strong>是一种递归的数据结构，它或者为空（null），或者是含有范型元素的节点和指向另一条链表的引用。</p></blockquote><p>这是《算法（第四版）》中链表的定义，可以说是晦涩难懂。大白讲就是递归无非就是你知道一个点才能知道下一个点，而每个点可能为空，可能为指向一个点或者指向空的点。<br>其中最简单的链表毫无疑问是单向链表，也是本篇文件所实现的数据结构。</p><h3 id="单向链表的节点"><a href="#单向链表的节点" class="headerlink" title="单向链表的节点"></a>单向链表的节点</h3><p>单向链表的每个节点包含两个部分，当前存放的数据value和指向下一个节点的指针next。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">value, next = <span class="literal">null</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单向链表的实现"><a href="#单向链表的实现" class="headerlink" title="单向链表的实现"></a>单向链表的实现</h3><p>这里实现查找，增加和删除是通过节点的值来操作，有的链表的查找，增加和删除的实现是通过索引（index）实现，原理差不多，注意代码的鲁棒性即可，这里只是为了突出链表的特点，所以不再实现。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.head = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.tail = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">find</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 查找某个元素</span></span><br><span class="line">        <span class="keyword">let</span> currentNode = <span class="built_in">this</span>.head;</span><br><span class="line">        <span class="keyword">while</span>(currentNode &amp;&amp; currentNode.value !== value) &#123;</span><br><span class="line">            currentNode = currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> currentNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">find</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 查找某个元素</span></span><br><span class="line">        <span class="keyword">let</span> currentNode = <span class="built_in">this</span>.head;</span><br><span class="line">        <span class="keyword">while</span>(currentNode &amp;&amp; currentNode.value !== value) &#123;</span><br><span class="line">            currentNode = currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> currentNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">append</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 向链表尾部添加节点</span></span><br><span class="line">        <span class="keyword">const</span> node = <span class="keyword">new</span> Node(value);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.head) &#123;</span><br><span class="line">            <span class="comment">// 链表为空时，头部添加</span></span><br><span class="line">            <span class="built_in">this</span>.head = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 尾部添加</span></span><br><span class="line">            <span class="built_in">this</span>.tail.next = node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.tail = node;</span><br><span class="line">        <span class="built_in">this</span>.size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">insert</span>(<span class="params">prev, item</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 插入节点</span></span><br><span class="line">        <span class="keyword">const</span> prevNode = <span class="built_in">this</span>.find(prev);</span><br><span class="line">        <span class="keyword">if</span> (!prevNode) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> node = <span class="keyword">new</span> Node(item, prevNode.next);</span><br><span class="line">        <span class="keyword">if</span> (!node.next) &#123;</span><br><span class="line">            <span class="built_in">this</span>.tail = node;</span><br><span class="line">        &#125;</span><br><span class="line">        prevNode.next = node;</span><br><span class="line">        <span class="built_in">this</span>.size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">remove</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> node = <span class="built_in">this</span>.find(value);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.head === node) &#123;</span><br><span class="line">            <span class="comment">// 删除头节点</span></span><br><span class="line">            <span class="built_in">this</span>.head = <span class="built_in">this</span>.head.next;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">this</span>.head?.next) &#123;</span><br><span class="line">                <span class="built_in">this</span>.tail = <span class="built_in">this</span>.head;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> prev = <span class="built_in">this</span>.head;</span><br><span class="line">        <span class="keyword">while</span>(prev?.next &amp;&amp; prev?.next !== node) &#123;</span><br><span class="line">            prev = prev.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!prev?.next) &#123;</span><br><span class="line">            <span class="comment">// 不存在需要删除的节点</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        prev.next = node.next;</span><br><span class="line">        <span class="keyword">if</span> (!prev.next) &#123;</span><br><span class="line">            <span class="built_in">this</span>.tail = prev;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">output</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 打印节点</span></span><br><span class="line">        <span class="keyword">let</span> currentNode = <span class="built_in">this</span>.head;</span><br><span class="line">        <span class="keyword">while</span> (currentNode) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(currentNode.value);</span><br><span class="line">            currentNode = currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为什么要用链表"><a href="#为什么要用链表" class="headerlink" title="为什么要用链表"></a>为什么要用链表</h2><ul><li>因为定义链表不需要指定长度，所以链表的空间效率是要高于数组的。</li><li>链表的查找插入和删除的时间复杂度是不同于数组的。</li><li>写操作多，读操作少的情况下，链表优于数组。</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;链表应该是面试时被提及最频繁的数据结构。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《剑指Offer》&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://pangpangfei.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="JavaScript" scheme="https://pangpangfei.github.io/tags/JavaScript/"/>
    
    <category term="数组" scheme="https://pangpangfei.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="数据结构" scheme="https://pangpangfei.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="算法" scheme="https://pangpangfei.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数组</title>
    <link href="https://pangpangfei.github.io/2021/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84/"/>
    <id>https://pangpangfei.github.io/2021/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84/</id>
    <published>2021-05-19T11:57:36.000Z</published>
    <updated>2021-05-19T13:29:16.645Z</updated>
    
    <content type="html"><![CDATA[<p>想写一篇数组的文章作为数据结构的开始。</p><span id="more"></span><h2 id="数据结构中的数组"><a href="#数据结构中的数组" class="headerlink" title="数据结构中的数组"></a>数据结构中的数组</h2><p>数组是有限个相同类型的变量所组成的有序集合。</p><h3 id="数组的操作"><a href="#数组的操作" class="headerlink" title="数组的操作"></a>数组的操作</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>创建数组时，先指定数组的容量大小，然后根据大小分配内存，数组在内存中<strong>顺序存储</strong>。</p><h4 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h4><p>数组中的每一个元素都有一个下标，下标从0开始，如果下标超过数组的末尾的下标，就会发生数组越界。算法复杂度为O(1)。</p><h5 id="数组的下标为什么从0开始"><a href="#数组的下标为什么从0开始" class="headerlink" title="数组的下标为什么从0开始"></a>数组的下标为什么从0开始</h5><p>从数组中存储的数据模型来看，下标最精确的意思是<strong>偏移量</strong>，a[0]的偏移量是0，即为首地址。a[i]的偏移量是i，寻址公式就是<br><code>a[i]_address = base_address + i*data_type_size</code><br>如果下标从1开始，那对应的寻址公式<br><code>a[i]_address = base_address + （i-1）*data_type_size</code><br>对CPU来说，每次随机访问，就多了一次运算，多发一条指令。</p><h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><p>利用下标赋值，算法复杂度为O(1)。</p><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>算法复杂度为O(n),插入操作会把插入点后面的元素都向后移动一位。</p><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>算法复杂度为O(n),删除操作会把删除点后面的元素都向前移动一位。</p><h3 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h3><p>因为数组在创建的时候会预先分配内存，在数组没有填满的时候，数组的空间效率很低，为了解决这个问题，人们发明了动态数组。<br>所谓的动态数组就是为了<strong>避免内存浪费</strong>，先预先为数组开辟较小的内存空间，当添加的数组超过数组的长度的时候，再创建一个新的数组，新数组的长度是老数组的n（一般为2）倍，把老数组的数组复制到新数组中，然后释放掉老数组的内存。<br>这样就能保证内存的合理运用，但是每次扩容都会有大量的额外操作，会降低时间性能。</p><h2 id="V8引擎中的JavaScript数组"><a href="#V8引擎中的JavaScript数组" class="headerlink" title="V8引擎中的JavaScript数组"></a>V8引擎中的JavaScript数组</h2><p>V8中的js数组在不同的条件下会使用不同的模式：<strong>Fast Elements</strong>，<strong>Dictionary Elements</strong>和<strong>Dictionary Element</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;想写一篇数组的文章作为数据结构的开始。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://pangpangfei.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数组" scheme="https://pangpangfei.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="数据结构" scheme="https://pangpangfei.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="算法" scheme="https://pangpangfei.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript实现Constructor（构造器）模式</title>
    <link href="https://pangpangfei.github.io/2021/05/17/JavaScript%E5%AE%9E%E7%8E%B0Constructor%EF%BC%88%E6%9E%84%E9%80%A0%E5%99%A8%EF%BC%89%E6%A8%A1%E5%BC%8F/"/>
    <id>https://pangpangfei.github.io/2021/05/17/JavaScript%E5%AE%9E%E7%8E%B0Constructor%EF%BC%88%E6%9E%84%E9%80%A0%E5%99%A8%EF%BC%89%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-05-17T12:40:00.000Z</published>
    <updated>2021-07-21T05:24:51.598Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在经典面向对象编程语言中，Constructor是一种在内存已分配给该对象的情况下，用于初始化新建对象的特殊方法。在JavaScript中，几乎所有的东西都是对象，我们通常最感兴趣的是object构造器。</p><ul><li>《JavaScript设计模式》</li></ul></blockquote><span id="more"></span><h2 id="大白话讲什么是构造器模式"><a href="#大白话讲什么是构造器模式" class="headerlink" title="大白话讲什么是构造器模式"></a>大白话讲什么是构造器模式</h2><p>不论是在JavaScript，Java或是C#，亦或是其他面向对象语言中，都有个new操作符，当你new一个对象的时候，你就已经玩过了构造器模式。其作用就是创建一个给对象分配一块内存空间，并且创建该对象的属性和方法。</p><h2 id="JavaScript怎么使用构造器"><a href="#JavaScript怎么使用构造器" class="headerlink" title="JavaScript怎么使用构造器"></a>JavaScript怎么使用构造器</h2><h3 id="ES6之前"><a href="#ES6之前" class="headerlink" title="ES6之前"></a>ES6之前</h3><p>ES6之前的JavaScript不支持类的概念，但是可以通过new关键字将特殊的构造器函数实例化成一个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, gender</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.gender = gender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.greeting = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;你好！我叫&#x27;</span> + <span class="built_in">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> lxw = <span class="keyword">new</span> Person(<span class="string">&#x27;刘希玮&#x27;</span>, <span class="number">24</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">var</span> yxm = <span class="keyword">new</span> Person(<span class="string">&#x27;岳向淼&#x27;</span>, <span class="number">25</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(lxw.greeting());</span><br><span class="line"><span class="built_in">console</span>.log(yxm.greeting());</span><br></pre></td></tr></table></figure><h3 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h3><p>ES6 支持了类的定义。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name, age, gender</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">greeting</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`你好！我叫<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> lxw = <span class="keyword">new</span> Person(<span class="string">&#x27;刘希玮&#x27;</span>, <span class="number">24</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">const</span> yxm = <span class="keyword">new</span> Person(<span class="string">&#x27;岳向淼&#x27;</span>, <span class="number">25</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(lxw.greeting());</span><br><span class="line"><span class="built_in">console</span>.log(yxm.greeting());</span><br></pre></td></tr></table></figure><h2 id="为什么要用构造器"><a href="#为什么要用构造器" class="headerlink" title="为什么要用构造器"></a>为什么要用构造器</h2><p>为啥？面向对象就完事了！</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在经典面向对象编程语言中，Constructor是一种在内存已分配给该对象的情况下，用于初始化新建对象的特殊方法。在JavaScript中，几乎所有的东西都是对象，我们通常最感兴趣的是object构造器。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《JavaScript设计模式》&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://pangpangfei.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="JavaScript" scheme="https://pangpangfei.github.io/tags/JavaScript/"/>
    
    <category term="设计模式" scheme="https://pangpangfei.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="构造器模式" scheme="https://pangpangfei.github.io/tags/%E6%9E%84%E9%80%A0%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>截止2021年5月的HTML总结</title>
    <link href="https://pangpangfei.github.io/2021/05/15/%E6%88%AA%E6%AD%A22021%E5%B9%B45%E6%9C%88%E7%9A%84HTML%E6%80%BB%E7%BB%93/"/>
    <id>https://pangpangfei.github.io/2021/05/15/%E6%88%AA%E6%AD%A22021%E5%B9%B45%E6%9C%88%E7%9A%84HTML%E6%80%BB%E7%BB%93/</id>
    <published>2021-05-15T03:39:38.000Z</published>
    <updated>2021-05-15T04:16:45.809Z</updated>
    
    <content type="html"><![CDATA[<p>截止到2021年5月的html的知识脑图。包含了所有标签属性和草案语法，废弃的语法不再记录。其中标签的分类按照我自己的记忆习惯分的。</p><span id="more"></span><p><em>图片为svg格式，可以在浏览器新标签页打开图片确保能看清图片。</em><br><img src="/images/htmlzongjie.svg" alt="html脑图"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;截止到2021年5月的html的知识脑图。包含了所有标签属性和草案语法，废弃的语法不再记录。其中标签的分类按照我自己的记忆习惯分的。&lt;/p&gt;</summary>
    
    
    
    <category term="HTML" scheme="https://pangpangfei.github.io/categories/HTML/"/>
    
    
    <category term="HTML" scheme="https://pangpangfei.github.io/tags/HTML/"/>
    
    <category term="DOCTYPE" scheme="https://pangpangfei.github.io/tags/DOCTYPE/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xiangmiao Yue</title>
  
  <subtitle>确保每天都在进步</subtitle>
  <link href="https://pangpangfei.github.io/atom.xml" rel="self"/>
  
  <link href="https://pangpangfei.github.io/"/>
  <updated>2021-06-11T15:22:44.458Z</updated>
  <id>https://pangpangfei.github.io/</id>
  
  <author>
    <name>Yue/53795936@qq.com</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript实现单例模式</title>
    <link href="https://pangpangfei.github.io/2021/06/11/JavaScript%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://pangpangfei.github.io/2021/06/11/JavaScript%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-06-11T13:29:06.000Z</published>
    <updated>2021-06-11T15:22:44.458Z</updated>
    
    <content type="html"><![CDATA[<p>我前司的后端老大哥，看见一个面试者就让人先手写个单例。</p><span id="more"></span><h2 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h2><p>简单点儿讲就是一个类仅提供一个实例，该供全局使用。</p><h2 id="单例解决的问题"><a href="#单例解决的问题" class="headerlink" title="单例解决的问题"></a>单例解决的问题</h2><p>一个全局使用的类频繁地创建与销毁。</p><h2 id="JavaScript实现单例"><a href="#JavaScript实现单例" class="headerlink" title="JavaScript实现单例"></a>JavaScript实现单例</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">getInstance</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.instance) &#123;</span><br><span class="line">            <span class="built_in">this</span>.instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Singleton.getInstance() === Singleton.getInstance()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>在上面的代码可以看出，区别于正常的类创建实例，单例模式实例的创建是在类的内部实现的，而且构造函数是不提供给外部使用的。</p><h2 id="延时构建"><a href="#延时构建" class="headerlink" title="延时构建"></a>延时构建</h2><p>研究单例到这里，你会不会有这样的想法，为什么不直接用一个*对象(Object)*来表示单例呢，这样用起来不是简单又大方？<br>这就引出了单例的一个重要的特征就是延时构建。<br>当我们用对象来实现一个单例的时候，在它初始化的时候就会被添加到上下文环境，而<strong>占用内存资源</strong>，而通过单例生成的对象知道使用静态类的时候才会使用资源。</p><h2 id="其他语言中的单例"><a href="#其他语言中的单例" class="headerlink" title="其他语言中的单例"></a>其他语言中的单例</h2><p>为什么要提其他语言中的单例呢，因为JavaScript区别于其他大多数语言的地方是JavaScript是<strong>单线程</strong>的。<br>多线程中资源是不共享的，所以在多线程的语言中，往往可以通过加<strong>锁</strong>实现单例。</p><h2 id="通过静态变量构建"><a href="#通过静态变量构建" class="headerlink" title="通过静态变量构建"></a>通过静态变量构建</h2><p>静态变量在线程之间是共享的，所以其他语言也可以通过静态变量实现单例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">getInstance</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Singleton.getInstance() === Singleton.getInstance()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>但是这段代码又没有实现<strong>构建延迟</strong>，所以我们通过下面的方法实现一下构建延迟，JavaScript中的class没有私有类的概念，所以下面的代码为伪代码，仅作为理解其他语言的参考。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">getInstance</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Nested.instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Nested</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>可是你在工作中经常单例吗。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我前司的后端老大哥，看见一个面试者就让人先手写个单例。&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://pangpangfei.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="JavaScript" scheme="https://pangpangfei.github.io/tags/JavaScript/"/>
    
    <category term="设计模式" scheme="https://pangpangfei.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="单例模式" scheme="https://pangpangfei.github.io/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript实现链表</title>
    <link href="https://pangpangfei.github.io/2021/05/30/JavaScript%E5%AE%9E%E7%8E%B0%E9%93%BE%E8%A1%A8/"/>
    <id>https://pangpangfei.github.io/2021/05/30/JavaScript%E5%AE%9E%E7%8E%B0%E9%93%BE%E8%A1%A8/</id>
    <published>2021-05-30T13:56:29.000Z</published>
    <updated>2021-05-30T15:56:38.211Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>链表应该是面试时被提及最频繁的数据结构。</p><ul><li>《剑指Offer》</li></ul></blockquote><span id="more"></span><h2 id="什么是链表"><a href="#什么是链表" class="headerlink" title="什么是链表"></a>什么是链表</h2><blockquote><p><strong>链表</strong>是一种递归的数据结构，它或者为空（null），或者是含有范型元素的节点和指向另一条链表的引用。</p></blockquote><p>这是《算法（第四版）》中链表的定义，可以说是晦涩难懂。大白讲就是递归无非就是你知道一个点才能知道下一个点，而每个点可能为空，可能为指向一个点或者指向空的点。<br>其中最简单的链表毫无疑问是单向链表，也是本篇文件所实现的数据结构。</p><h3 id="单向链表的节点"><a href="#单向链表的节点" class="headerlink" title="单向链表的节点"></a>单向链表的节点</h3><p>单向链表的每个节点包含两个部分，当前存放的数据value和指向下一个节点的指针next。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">value, next = <span class="literal">null</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单向链表的实现"><a href="#单向链表的实现" class="headerlink" title="单向链表的实现"></a>单向链表的实现</h3><p>这里实现查找，增加和删除是通过节点的值来操作，有的链表的查找，增加和删除的实现是通过索引（index）实现，原理差不多，注意代码的鲁棒性即可，这里只是为了突出链表的特点，所以不再实现。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.head = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.tail = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">find</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 查找某个元素</span></span><br><span class="line">        <span class="keyword">let</span> currentNode = <span class="built_in">this</span>.head;</span><br><span class="line">        <span class="keyword">while</span>(currentNode &amp;&amp; currentNode.value !== value) &#123;</span><br><span class="line">            currentNode = currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> currentNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">find</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 查找某个元素</span></span><br><span class="line">        <span class="keyword">let</span> currentNode = <span class="built_in">this</span>.head;</span><br><span class="line">        <span class="keyword">while</span>(currentNode &amp;&amp; currentNode.value !== value) &#123;</span><br><span class="line">            currentNode = currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> currentNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">append</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 向链表尾部添加节点</span></span><br><span class="line">        <span class="keyword">const</span> node = <span class="keyword">new</span> Node(value);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.head) &#123;</span><br><span class="line">            <span class="comment">// 链表为空时，头部添加</span></span><br><span class="line">            <span class="built_in">this</span>.head = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 尾部添加</span></span><br><span class="line">            <span class="built_in">this</span>.tail.next = node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.tail = node;</span><br><span class="line">        <span class="built_in">this</span>.size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">insert</span>(<span class="params">prev, item</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 插入节点</span></span><br><span class="line">        <span class="keyword">const</span> prevNode = <span class="built_in">this</span>.find(prev);</span><br><span class="line">        <span class="keyword">if</span> (!prevNode) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> node = <span class="keyword">new</span> Node(item, prevNode.next);</span><br><span class="line">        <span class="keyword">if</span> (!node.next) &#123;</span><br><span class="line">            <span class="built_in">this</span>.tail = node;</span><br><span class="line">        &#125;</span><br><span class="line">        prevNode.next = node;</span><br><span class="line">        <span class="built_in">this</span>.size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">remove</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> node = <span class="built_in">this</span>.find(value);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.head === node) &#123;</span><br><span class="line">            <span class="comment">// 删除头节点</span></span><br><span class="line">            <span class="built_in">this</span>.head = <span class="built_in">this</span>.head.next;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">this</span>.head?.next) &#123;</span><br><span class="line">                <span class="built_in">this</span>.tail = <span class="built_in">this</span>.head;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> prev = <span class="built_in">this</span>.head;</span><br><span class="line">        <span class="keyword">while</span>(prev?.next &amp;&amp; prev?.next !== node) &#123;</span><br><span class="line">            prev = prev.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!prev?.next) &#123;</span><br><span class="line">            <span class="comment">// 不存在需要删除的节点</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        prev.next = node.next;</span><br><span class="line">        <span class="keyword">if</span> (!prev.next) &#123;</span><br><span class="line">            <span class="built_in">this</span>.tail = prev;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">output</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 打印节点</span></span><br><span class="line">        <span class="keyword">let</span> currentNode = <span class="built_in">this</span>.head;</span><br><span class="line">        <span class="keyword">while</span> (currentNode) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(currentNode.value);</span><br><span class="line">            currentNode = currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为什么要用链表"><a href="#为什么要用链表" class="headerlink" title="为什么要用链表"></a>为什么要用链表</h2><ul><li>因为定义链表不需要指定长度，所以链表的空间效率是要高于数组的。</li><li>链表的查找插入和删除的时间复杂度是不同于数组的。</li><li>写操作多，读操作少的情况下，链表优于数组。</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;链表应该是面试时被提及最频繁的数据结构。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《剑指Offer》&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://pangpangfei.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="JavaScript" scheme="https://pangpangfei.github.io/tags/JavaScript/"/>
    
    <category term="数组" scheme="https://pangpangfei.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="数据结构" scheme="https://pangpangfei.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="算法" scheme="https://pangpangfei.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数组</title>
    <link href="https://pangpangfei.github.io/2021/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84/"/>
    <id>https://pangpangfei.github.io/2021/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84/</id>
    <published>2021-05-19T11:57:36.000Z</published>
    <updated>2021-05-19T13:29:16.645Z</updated>
    
    <content type="html"><![CDATA[<p>想写一篇数组的文章作为数据结构的开始。</p><span id="more"></span><h2 id="数据结构中的数组"><a href="#数据结构中的数组" class="headerlink" title="数据结构中的数组"></a>数据结构中的数组</h2><p>数组是有限个相同类型的变量所组成的有序集合。</p><h3 id="数组的操作"><a href="#数组的操作" class="headerlink" title="数组的操作"></a>数组的操作</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>创建数组时，先指定数组的容量大小，然后根据大小分配内存，数组在内存中<strong>顺序存储</strong>。</p><h4 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h4><p>数组中的每一个元素都有一个下标，下标从0开始，如果下标超过数组的末尾的下标，就会发生数组越界。算法复杂度为O(1)。</p><h5 id="数组的下标为什么从0开始"><a href="#数组的下标为什么从0开始" class="headerlink" title="数组的下标为什么从0开始"></a>数组的下标为什么从0开始</h5><p>从数组中存储的数据模型来看，下标最精确的意思是<strong>偏移量</strong>，a[0]的偏移量是0，即为首地址。a[i]的偏移量是i，寻址公式就是<br><code>a[i]_address = base_address + i*data_type_size</code><br>如果下标从1开始，那对应的寻址公式<br><code>a[i]_address = base_address + （i-1）*data_type_size</code><br>对CPU来说，每次随机访问，就多了一次运算，多发一条指令。</p><h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><p>利用下标赋值，算法复杂度为O(1)。</p><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>算法复杂度为O(n),插入操作会把插入点后面的元素都向后移动一位。</p><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>算法复杂度为O(n),删除操作会把删除点后面的元素都向前移动一位。</p><h3 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h3><p>因为数组在创建的时候会预先分配内存，在数组没有填满的时候，数组的空间效率很低，为了解决这个问题，人们发明了动态数组。<br>所谓的动态数组就是为了<strong>避免内存浪费</strong>，先预先为数组开辟较小的内存空间，当添加的数组超过数组的长度的时候，再创建一个新的数组，新数组的长度是老数组的n（一般为2）倍，把老数组的数组复制到新数组中，然后释放掉老数组的内存。<br>这样就能保证内存的合理运用，但是每次扩容都会有大量的额外操作，会降低时间性能。</p><h2 id="V8引擎中的JavaScript数组"><a href="#V8引擎中的JavaScript数组" class="headerlink" title="V8引擎中的JavaScript数组"></a>V8引擎中的JavaScript数组</h2><p>V8中的js数组在不同的条件下会使用不同的模式：<strong>Fast Elements</strong>，<strong>Dictionary Elements</strong>和<strong>Dictionary Element</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;想写一篇数组的文章作为数据结构的开始。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://pangpangfei.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数组" scheme="https://pangpangfei.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="数据结构" scheme="https://pangpangfei.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="算法" scheme="https://pangpangfei.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript实现Constructor（构造器）模式</title>
    <link href="https://pangpangfei.github.io/2021/05/17/JavaScript%E5%AE%9E%E7%8E%B0Constructor%EF%BC%88%E6%9E%84%E9%80%A0%E5%99%A8%EF%BC%89%E6%A8%A1%E5%BC%8F/"/>
    <id>https://pangpangfei.github.io/2021/05/17/JavaScript%E5%AE%9E%E7%8E%B0Constructor%EF%BC%88%E6%9E%84%E9%80%A0%E5%99%A8%EF%BC%89%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-05-17T12:40:00.000Z</published>
    <updated>2021-05-17T13:51:15.331Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在经典面向对象编程语言中，Constructor是一种在内存已分配给该对象的情况下，用于初始化新建对象的特殊方法。在JavaScript中，几乎所有的东西都是对象，我们通常最感兴趣的是object构造器。</p><ul><li>《JavaScript设计模式》</li></ul></blockquote><span id="more"></span><h2 id="大白话讲什么是构造器模式"><a href="#大白话讲什么是构造器模式" class="headerlink" title="大白话讲什么是构造器模式"></a>大白话讲什么是构造器模式</h2><p>不论是在JavaScript，Java或是C#，亦或是其他面向对象语言中，都有个new操作符，当你new一个对象的时候，你就已经玩过了构造器模式。其作用就是创建一个给对象分配一块内存空间，并且创建该对象的属性和方法。</p><h2 id="JavaScript怎么使用构造器"><a href="#JavaScript怎么使用构造器" class="headerlink" title="JavaScript怎么使用构造器"></a>JavaScript怎么使用构造器</h2><h3 id="ES6之前"><a href="#ES6之前" class="headerlink" title="ES6之前"></a>ES6之前</h3><p>ES6之前的JavaScript不支持类的概念，但是可以通过new关键字将特殊的构造器函数实例化成一个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, gender</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.gender = gender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.greeting = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;你好！我叫&#x27;</span> + <span class="built_in">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> lxw = <span class="keyword">new</span> Person(<span class="string">&quot;刘希玮&quot;</span>, <span class="number">24</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">var</span> yxm = <span class="keyword">new</span> Person(<span class="string">&quot;岳向淼&quot;</span>, <span class="number">25</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(lxw.greeting());</span><br><span class="line"><span class="built_in">console</span>.log(yxm.greeting());</span><br></pre></td></tr></table></figure><h3 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h3><p>ES6 支持了类的定义。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name, age, gender</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">greeting</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`你好！我叫<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> lxw = <span class="keyword">new</span> Person(<span class="string">&quot;刘希玮&quot;</span>, <span class="number">24</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">const</span> yxm = <span class="keyword">new</span> Person(<span class="string">&quot;岳向淼&quot;</span>, <span class="number">25</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(lxw.greeting());</span><br><span class="line"><span class="built_in">console</span>.log(yxm.greeting());</span><br></pre></td></tr></table></figure><h2 id="为什么要用构造器"><a href="#为什么要用构造器" class="headerlink" title="为什么要用构造器"></a>为什么要用构造器</h2><p>为啥？面向对象就完事了！</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在经典面向对象编程语言中，Constructor是一种在内存已分配给该对象的情况下，用于初始化新建对象的特殊方法。在JavaScript中，几乎所有的东西都是对象，我们通常最感兴趣的是object构造器。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《JavaScript设计模式》&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://pangpangfei.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="JavaScript" scheme="https://pangpangfei.github.io/tags/JavaScript/"/>
    
    <category term="设计模式" scheme="https://pangpangfei.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="构造器模式" scheme="https://pangpangfei.github.io/tags/%E6%9E%84%E9%80%A0%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>截止2021年5月的HTML总结</title>
    <link href="https://pangpangfei.github.io/2021/05/15/%E6%88%AA%E6%AD%A22021%E5%B9%B45%E6%9C%88%E7%9A%84HTML%E6%80%BB%E7%BB%93/"/>
    <id>https://pangpangfei.github.io/2021/05/15/%E6%88%AA%E6%AD%A22021%E5%B9%B45%E6%9C%88%E7%9A%84HTML%E6%80%BB%E7%BB%93/</id>
    <published>2021-05-15T03:39:38.000Z</published>
    <updated>2021-05-15T04:16:45.809Z</updated>
    
    <content type="html"><![CDATA[<p>截止到2021年5月的html的知识脑图。包含了所有标签属性和草案语法，废弃的语法不再记录。其中标签的分类按照我自己的记忆习惯分的。</p><span id="more"></span><p><em>图片为svg格式，可以在浏览器新标签页打开图片确保能看清图片。</em><br><img src="/images/htmlzongjie.svg" alt="html脑图"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;截止到2021年5月的html的知识脑图。包含了所有标签属性和草案语法，废弃的语法不再记录。其中标签的分类按照我自己的记忆习惯分的。&lt;/p&gt;</summary>
    
    
    
    <category term="HTML" scheme="https://pangpangfei.github.io/categories/HTML/"/>
    
    
    <category term="HTML" scheme="https://pangpangfei.github.io/tags/HTML/"/>
    
    <category term="DOCTYPE" scheme="https://pangpangfei.github.io/tags/DOCTYPE/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xiangmiao Yue</title>
  
  <subtitle>确保每天都在进步</subtitle>
  <link href="https://pangpangfei.github.io/atom.xml" rel="self"/>
  
  <link href="https://pangpangfei.github.io/"/>
  <updated>2021-05-19T13:29:16.645Z</updated>
  <id>https://pangpangfei.github.io/</id>
  
  <author>
    <name>Yue/53795936@qq.com</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数组</title>
    <link href="https://pangpangfei.github.io/2021/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84/"/>
    <id>https://pangpangfei.github.io/2021/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84/</id>
    <published>2021-05-19T11:57:36.000Z</published>
    <updated>2021-05-19T13:29:16.645Z</updated>
    
    <content type="html"><![CDATA[<p>想写一篇数组的文章作为数据结构的开始。</p><span id="more"></span><h2 id="数据结构中的数组"><a href="#数据结构中的数组" class="headerlink" title="数据结构中的数组"></a>数据结构中的数组</h2><p>数组是有限个相同类型的变量所组成的有序集合。</p><h3 id="数组的操作"><a href="#数组的操作" class="headerlink" title="数组的操作"></a>数组的操作</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>创建数组时，先指定数组的容量大小，然后根据大小分配内存，数组在内存中<strong>顺序存储</strong>。</p><h4 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h4><p>数组中的每一个元素都有一个下标，下标从0开始，如果下标超过数组的末尾的下标，就会发生数组越界。算法复杂度为O(1)。</p><h5 id="数组的下标为什么从0开始"><a href="#数组的下标为什么从0开始" class="headerlink" title="数组的下标为什么从0开始"></a>数组的下标为什么从0开始</h5><p>从数组中存储的数据模型来看，下标最精确的意思是<strong>偏移量</strong>，a[0]的偏移量是0，即为首地址。a[i]的偏移量是i，寻址公式就是<br><code>a[i]_address = base_address + i*data_type_size</code><br>如果下标从1开始，那对应的寻址公式<br><code>a[i]_address = base_address + （i-1）*data_type_size</code><br>对CPU来说，每次随机访问，就多了一次运算，多发一条指令。</p><h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><p>利用下标赋值，算法复杂度为O(1)。</p><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>算法复杂度为O(n),插入操作会把插入点后面的元素都向后移动一位。</p><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>算法复杂度为O(n),删除操作会把删除点后面的元素都向前移动一位。</p><h3 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h3><p>因为数组在创建的时候会预先分配内存，在数组没有填满的时候，数组的空间效率很低，为了解决这个问题，人们发明了动态数组。<br>所谓的动态数组就是为了<strong>避免内存浪费</strong>，先预先为数组开辟较小的内存空间，当添加的数组超过数组的长度的时候，再创建一个新的数组，新数组的长度是老数组的n（一般为2）倍，把老数组的数组复制到新数组中，然后释放掉老数组的内存。<br>这样就能保证内存的合理运用，但是每次扩容都会有大量的额外操作，会降低时间性能。</p><h2 id="V8引擎中的JavaScript数组"><a href="#V8引擎中的JavaScript数组" class="headerlink" title="V8引擎中的JavaScript数组"></a>V8引擎中的JavaScript数组</h2><p>V8中的js数组在不同的条件下会使用不同的模式：<strong>Fast Elements</strong>，<strong>Dictionary Elements</strong>和<strong>Dictionary Element</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;想写一篇数组的文章作为数据结构的开始。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://pangpangfei.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数组" scheme="https://pangpangfei.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="数据结构" scheme="https://pangpangfei.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="算法" scheme="https://pangpangfei.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript实现Constructor（构造器）模式</title>
    <link href="https://pangpangfei.github.io/2021/05/17/JavaScript%E5%AE%9E%E7%8E%B0Constructor%EF%BC%88%E6%9E%84%E9%80%A0%E5%99%A8%EF%BC%89%E6%A8%A1%E5%BC%8F/"/>
    <id>https://pangpangfei.github.io/2021/05/17/JavaScript%E5%AE%9E%E7%8E%B0Constructor%EF%BC%88%E6%9E%84%E9%80%A0%E5%99%A8%EF%BC%89%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-05-17T12:40:00.000Z</published>
    <updated>2021-05-17T13:51:15.331Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在经典面向对象编程语言中，Constructor是一种在内存已分配给该对象的情况下，用于初始化新建对象的特殊方法。在JavaScript中，几乎所有的东西都是对象，我们通常最感兴趣的是object构造器。</p><ul><li>《JavaScript设计模式》</li></ul></blockquote><span id="more"></span><h2 id="大白话讲什么是构造器模式"><a href="#大白话讲什么是构造器模式" class="headerlink" title="大白话讲什么是构造器模式"></a>大白话讲什么是构造器模式</h2><p>不论是在JavaScript，Java或是C#，亦或是其他面向对象语言中，都有个new操作符，当你new一个对象的时候，你就已经玩过了构造器模式。其作用就是创建一个给对象分配一块内存空间，并且创建该对象的属性和方法。</p><h2 id="JavaScript怎么使用构造器"><a href="#JavaScript怎么使用构造器" class="headerlink" title="JavaScript怎么使用构造器"></a>JavaScript怎么使用构造器</h2><h3 id="ES6之前"><a href="#ES6之前" class="headerlink" title="ES6之前"></a>ES6之前</h3><p>ES6之前的JavaScript不支持类的概念，但是可以通过new关键字将特殊的构造器函数实例化成一个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, gender</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.gender = gender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.greeting = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;你好！我叫&#x27;</span> + <span class="built_in">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> lxw = <span class="keyword">new</span> Person(<span class="string">&quot;刘希玮&quot;</span>, <span class="number">24</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">var</span> yxm = <span class="keyword">new</span> Person(<span class="string">&quot;岳向淼&quot;</span>, <span class="number">25</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(lxw.greeting());</span><br><span class="line"><span class="built_in">console</span>.log(yxm.greeting());</span><br></pre></td></tr></table></figure><h3 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h3><p>ES6 支持了类的定义。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name, age, gender</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">greeting</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`你好！我叫<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> lxw = <span class="keyword">new</span> Person(<span class="string">&quot;刘希玮&quot;</span>, <span class="number">24</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">const</span> yxm = <span class="keyword">new</span> Person(<span class="string">&quot;岳向淼&quot;</span>, <span class="number">25</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(lxw.greeting());</span><br><span class="line"><span class="built_in">console</span>.log(yxm.greeting());</span><br></pre></td></tr></table></figure><h2 id="为什么要用构造器"><a href="#为什么要用构造器" class="headerlink" title="为什么要用构造器"></a>为什么要用构造器</h2><p>为啥？面向对象就完事了！</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在经典面向对象编程语言中，Constructor是一种在内存已分配给该对象的情况下，用于初始化新建对象的特殊方法。在JavaScript中，几乎所有的东西都是对象，我们通常最感兴趣的是object构造器。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《JavaScript设计模式》&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://pangpangfei.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="JavaScript" scheme="https://pangpangfei.github.io/tags/JavaScript/"/>
    
    <category term="设计模式" scheme="https://pangpangfei.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="构造器模式" scheme="https://pangpangfei.github.io/tags/%E6%9E%84%E9%80%A0%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>截止2021年5月的HTML总结</title>
    <link href="https://pangpangfei.github.io/2021/05/15/%E6%88%AA%E6%AD%A22021%E5%B9%B45%E6%9C%88%E7%9A%84HTML%E6%80%BB%E7%BB%93/"/>
    <id>https://pangpangfei.github.io/2021/05/15/%E6%88%AA%E6%AD%A22021%E5%B9%B45%E6%9C%88%E7%9A%84HTML%E6%80%BB%E7%BB%93/</id>
    <published>2021-05-15T03:39:38.000Z</published>
    <updated>2021-05-15T04:16:45.809Z</updated>
    
    <content type="html"><![CDATA[<p>截止到2021年5月的html的知识脑图。包含了所有标签属性和草案语法，废弃的语法不再记录。其中标签的分类按照我自己的记忆习惯分的。</p><span id="more"></span><p><em>图片为svg格式，可以在浏览器新标签页打开图片确保能看清图片。</em><br><img src="/images/htmlzongjie.svg" alt="html脑图"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;截止到2021年5月的html的知识脑图。包含了所有标签属性和草案语法，废弃的语法不再记录。其中标签的分类按照我自己的记忆习惯分的。&lt;/p&gt;</summary>
    
    
    
    <category term="HTML" scheme="https://pangpangfei.github.io/categories/HTML/"/>
    
    
    <category term="HTML" scheme="https://pangpangfei.github.io/tags/HTML/"/>
    
    <category term="DOCTYPE" scheme="https://pangpangfei.github.io/tags/DOCTYPE/"/>
    
  </entry>
  
</feed>
